@using src.Common
@using src.Common.Enums.Pilot
@using src.Common.Filter
@using src.Components.UI.filter_flag

<div class="container">
    
    <div class="op">

        @if(filters_selecteds != null)
        {
            @foreach (var filter in filters_selecteds)
            {
                <FilterFlag closed_filter=OnDeletedFlag filter_option=filter />
            }
        }
        
        
        @foreach (var option in options)
        {
            <div class="wrapper">
                <button class="option @(expandedOptions.ContainsKey(option.Key) && expandedOptions[option.Key] ? "clicked" : "isntClicked")"
                        @onclick="() => OnOptClicked(option.Key)">
                    @option.Key
                    <div class="arrow-container">
                        <i class="fas fa-chevron-down arrow @(expandedOptions.ContainsKey(option.Key) && expandedOptions[option.Key] ? "ArrowClass" : "")"></i>
                    </div>
                </button>
                <ul class="options-dropdown @(expandedOptions.ContainsKey(option.Key) && expandedOptions[option.Key] ? "showDropDown" : "hideDropDown")">
                    @foreach (string opt in option.Value)
                    {
                        <li @onclick="() => OnFilterOptionClicked(option.Key, opt)">
                            @opt
                        </li>
                    }
                </ul>
            </div>
        }
    </div>
</div>

@code {
    public List<Dictionary<String, String>> filters_selecteds = new ();

    [Parameter]
    public EventCallback<Dictionary<string, string>> filters { get; set; }

    [Parameter]
    public Dictionary<string, List<string>> options { get; set; }

    public Dictionary<string, string>? selectedFilters { get; set; } = new();

    public Dictionary<string, bool> expandedOptions { get; set; } = new();

    private void OnOptClicked(string opt)
    {
        if (expandedOptions.ContainsKey(opt))
        {
            expandedOptions[opt] = !expandedOptions[opt]; 
        }
        else
        {
            expandedOptions[opt] = true; 
        }
        StateHasChanged();
    }

    public async Task OnFilterOptionClicked(String key, String opt)
    {
        if (selectedFilters.TryGetValue(key, out var currentValue) && currentValue == opt)
        {   

            selectedFilters[key] = null;

            if (filters_selecteds != null)
            {
                filters_selecteds.Select(d => d.Remove(key));
            }

        }
        else
        {
            selectedFilters[key] = opt;

            if (filters_selecteds.Any(d => d.ContainsKey(key)))
            {

                var filter = filters_selecteds.FirstOrDefault(d => d.ContainsKey(key));
                filter[key] = opt;
            }
            else
            {
                var filterTag = new Dictionary<String, String> { { key, opt } };
                filters_selecteds.Add(filterTag);
            }


        }

        if (filters.HasDelegate)
            await filters.InvokeAsync(selectedFilters);
    }

    public async Task OnDeletedFlag(Dictionary<String, String> filter)
    {



        var key = filter.First().Key;

        Console.WriteLine("Chave a deletar: ", filter.First().Key, " | Valor da chave a deletar: ", filter[key]);

        foreach (var dicionario in filters_selecteds)
        {
            dicionario[key] = null;

            Console.WriteLine(dicionario.Values);
        }


        await OnFilterOptionClicked(key, filter[key]);

        StateHasChanged();

    }
}